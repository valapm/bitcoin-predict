import { entry, getBalanceMerkleRoot, getEntryHex } from "../src/pm"
import { currentMarketContract } from "../src/contracts"
import { addLeaf, getMerklePath, merkelizeArray, verifyLeaf, updateLeaf, getMerkleRoot } from "../src/merkleTree"
import { sha256d } from "../src/sha"
import bsv from "bsv"

test("nikamoto", () => {
  const privKey1 = bsv.PrivateKey.fromRandom()

  const entry1: entry = {
    publicKey: privKey1.publicKey,
    balance: {
      shares: [1, 0],
      liquidity: 1
    },
    globalLiqidityFeePoolSave: 0,
    liquidityPoints: 0
  }

  const merkleRoot = getBalanceMerkleRoot([entry1], currentMarketContract)
  const lastEntryHex = getEntryHex(entry1, currentMarketContract)
  const lastLeaf = sha256d(lastEntryHex)
  const lastMerklePath = getMerklePath(1, [sha256d("00"), lastLeaf])

  expect(verifyLeaf(lastLeaf, lastMerklePath, merkleRoot)).toBe(true)

  const entry2: entry = {
    publicKey: privKey1.publicKey,
    balance: {
      shares: [0, 0],
      liquidity: 0
    },
    globalLiqidityFeePoolSave: 0,
    liquidityPoints: 0
  }

  let entry2Hex = getEntryHex(entry2, currentMarketContract)
  entry2Hex = entry2Hex.slice(entry2Hex.length - 64)

  const fakeEntry: entry = {
    publicKey: privKey1.publicKey,
    balance: {
      shares: [1000, 1000],
      liquidity: 1000
    },
    globalLiqidityFeePoolSave: 0,
    liquidityPoints: 0
  }

  const fakeEntryHex = getEntryHex(fakeEntry, currentMarketContract)
  // const fakeMerkleRoot = getBalanceMerkleRoot([fakeEntry], currentMarketContract)
  const fakeMerkleRoot = sha256d(fakeEntryHex)
  const fakeLeafHex = fakeMerkleRoot + entry2Hex
  const fakeLeaf = sha256d(fakeLeafHex)
  const newMerkleRoot = addLeaf(lastEntryHex, lastMerklePath, merkleRoot, fakeLeafHex)

  expect(newMerkleRoot).toBe(getMerkleRoot([sha256d("00"), lastLeaf, fakeLeaf]))

  let fakeMerklePath = getMerklePath(2, [sha256d("00"), lastLeaf, fakeLeaf])
  fakeMerklePath = entry2Hex + "01" + fakeMerklePath

  expect(verifyLeaf(sha256d(fakeEntryHex), fakeMerklePath, newMerkleRoot)).toBe(false)

  // const fakeEntry2: entry = {
  //   publicKey: privKey1.publicKey,
  //   balance: {
  //     shares: [0, 0],
  //     liquidity: 0
  //   },
  //   globalLiqidityFeePoolSave: 0,
  //   liquidityPoints: 0
  // }

  // const fakeEntry2Hex = sha256d(getEntryHex(fakeEntry2, currentMarketContract))

  // const newMerkleRoot2 = updateLeaf(fakeEntryHex, fakeEntry2Hex, fakeMerklePath, newMerkleRoot)

  // const fakeMerkleRoot2 = sha256d(fakeEntry2Hex)
  // const fakeLeaf2 = sha256d(fakeMerkleRoot2 + entry2Hex)
  // let fakeMerklePath2 = getMerklePath(2, [sha256d("00"), lastLeaf, fakeLeaf2])
  // fakeMerklePath2 = entry2Hex + "01" + fakeMerklePath2

  // expect(verifyLeaf(sha256d(fakeEntry2Hex), fakeMerklePath2, newMerkleRoot2)).toBe(true)
})
